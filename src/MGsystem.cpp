/*
 * Copyright (C) 1998, 2000-2007, 2010, 2011, 2012, 2013 SINTEF ICT,
 * Applied Mathematics, Norway.
 *
 * Contact information: E-mail: tor.dokken@sintef.no                      
 * SINTEF ICT, Department of Applied Mathematics,                         
 * P.O. Box 124 Blindern,                                                 
 * 0314 Oslo, Norway.                                                     
 *
 * This file is part of LSMG.
 *
 * LSMG is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version. 
 *
 * LSMG is distributed in the hope that it will be useful,        
 * but WITHOUT ANY WARRANTY; without even the implied warranty of         
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with LSMG. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * In accordance with Section 7(b) of the GNU Affero General Public
 * License, a covered work must retain the producer line in every data
 * file that is created or manipulated using LSMG.
 *
 * Other Usage
 * You can be released from the requirements of the license by purchasing
 * a commercial license. Buying such a license is mandatory as soon as you
 * develop commercial activities involving the LSMG library without
 * disclosing the source code of your own applications.
 *
 * This file may be used in accordance with the terms contained in a
 * written agreement between you and SINTEF ICT. 
 */

#include <MGsystem.h>

#include <UCBsplines.h>
#include <MBA.h>

//#include <cmath>
#include <math.h>
#include <algorithm>
#include <valarray>
using namespace std;


// Debug ???
static void errorAndExit(char* message) {
  cout << "ERROR: ";
  cout << message << endl;
  exit(-1);
}
//#define DEBUG_LSMG 1
#define DEBUG_0  1    // output such as number of iterations

#include <UCBsplineSurface.h>
#include <UCButils.h>
static void printGLgrid(const char filename[], boost::shared_ptr<GenMatrixType> pmat, double scale) {
  
  // ... by transferring to a B-spline surface,
  // that is, the area outside the usual surface domain will not be printed!
  // also note that it assumes that du=dv

  // Here, just take the domain over 
  double umin = 0.0;
  double vmin = 0.0;
  int m = pmat->noX()-3;
  int n = pmat->noY()-3;
  double umax = (double)m;
  double vmax = (double)n;

  //boost::shared_ptr<GenMatrixType> pmat(&mat);
  
  UCBspl::SplineSurface surf(pmat, umin, vmin, umax, vmax);
  UCBspl::printGLgrid(filename, surf, m+1, n+1);
}

static void printVTKgrid(const char filename[], const GenMatrixType& mat, double scale) {
  
  
  // Test for least squares approximation
  cout << "Printing grid to vtk structured points file: " << filename << "...... ";
  ofstream os(filename);

  int noU = mat.noX();
  int noV = mat.noY();

  double umin = 0.0;
  double vmin = 0.0;
  double umax = (double)(noU-1);;
  double vmax = (double)(noV-1);;
  double du = (umax - umin)/(double)(noU-1);
  double dv = (vmax - vmin)/(double)(noV-1);  

  os << "# vtk DataFile Version 2.0" << endl;
  os << "This file was generated by class UCButils (structured points)" << endl;
  os << "ASCII" << endl;
  os << "DATASET STRUCTURED_POINTS" << endl;
  os << "DIMENSIONS " << noU << " " << noV << " " << 1 << endl;
  os << "ORIGIN " << umin << " " << vmin << " " << 999 << endl;
  os << "SPACING " << du << " " << dv << " " << 999 << endl;
  os << "POINT_DATA " << noU*noV*1 << endl;
  os << "SCALARS volume_scalars float" << endl;
  os << "LOOKUP_TABLE default" << endl;

  // The points:
  int noPoints = noU*noV;

  double maxVal = mat(-1,-1);
  double minVal = mat(-1,-1);
  double sum=0;

  // z-arr row by row
  int i,j;
  for (j = 0; j < noV; j++) {
    double v = vmin + j*dv;
    for (i = 0; i < noU; i++) {
      double u = umin + i*du;
      double val = mat(i-1,j-1);
      sum += val;
      if (val > maxVal)
        maxVal = val;
      if (val < minVal)
        minVal = val;
      os << val*scale << '\n';
    }
  }

  cout << "minVal = " << minVal << "  maxVal = " << maxVal << " Mean = " << sum/(double)(noU*noV)<< endl; 
}



// ---------------------------------------------------------------------------
void MGsystem::residual(const LSsystem& lssys, GenMatrix<UCBspl_real>& r) const {

  // ??? Why is this function here.
  // It is also present in LSsystem !!!

  //
  // b - Ax

  // The residual will be RHS in the residual equation and must be represented
  // as a matrix (corresponds to b_ in this class)

  r.resize(lssys.n1_, lssys.n2_);
  int n = lssys.n1_*lssys.n2_; // The "one-dimensional" size of RHS and soluton vector

  for (int i = 0; i < n; i++) { // for each row no. i in the system matrix
    
    // Matrix-vector product: Ax for row no. i
    //double sum = lssys.rowMatVecMult(i, lssys.A_, lssys.x_);
    double sum = LSsystem::rowMatVecMult(i, lssys.A_, *lssys.x_);
    
    // Determine indices of b and r
    int k = i%lssys.n1_ - 1; // runs fastest (-1,...,n1-2)
    int l = i/lssys.n1_ - 1;
    
    r(k,l) = lssys.b_(k,l) - sum; // b - Ax  element
  }
}


static double residual(const std::vector<LSsystem*>& systems, int normType, bool scaled=false) {
  
  // normType = 0, l_inf norm
  // normType = 2, l_2 norm

  int noLevels = systems.size();

  if (noLevels == 0 || (normType != 0 && normType != 2)) {
#ifdef DEBUG_0
    cout << "ERROR: No equation system present" << endl;
#endif
    return 0.0;
  }

  if (normType == 0)
    return systems[noLevels-1]->residual_linf();
  else if (normType == 2)
    return systems[noLevels-1]->residual_l2(scaled);
  else
    return 0.;
}


// ---------------------------------------------------------------------------
double MGsystem::residual_l2(bool scaled) const {
  
  int normType = 2;
  return ::residual(systems_,normType,scaled);
}

// ---------------------------------------------------------------------------
double MGsystem::residual_linf() const {

  int normType = 0;
  return ::residual(systems_,normType);
}


// ---------------------------------------------------------------------------
void MGsystem::residual_restrictionInjection(const LSsystem& lssys, GenMatrix<UCBspl_real>& r) const {

  cout << "residual_restrictionInjection..." << endl;

  // NOTE 1: See the tech report

  // NOTE 2: It is assumed that projection is only done if the
  // grid has been refined from that coarse level earlier, thus
  // the modulus of (noX-3)/2 and (noY-3)/2 must be zero.
  //

  // The residual will be RHS in the residual equation and must be represented
  // as a matrix (corresponds to b_ in this class)
  int old_noX = lssys.n1_;
  int old_noY = lssys.n2_;

  if ((old_noX-3)%2 != 0 || (old_noY-3)%2 != 0) {
    cout << "ERROR, invalid grid for projection; see comments in the code above: " << old_noX << " " << old_noY << endl;
    exit(-1);
  }

  // Size of residual vector (repr. as a matrix) at the coarser level
  // See NOTE above.
  int noX = (old_noX-3)/2 + 3;
  int noY = (old_noY-3)/2 + 3;

  r.resize(noX, noY);

  int n = lssys.n1_*lssys.n2_; // The "one-dimensional" size of previous RHS and soluton vector

  // Indices in the new coarser matrix r
  int kk = -1;
  int ll = -1;

  // Every second row in A now because of injection
  int i = 0;
  while (i < n) {
    
    // Matrix-vector product: Ax for row no. i
    //double sum = lssys.rowMatVecMult(i, lssys.A_, lssys.x_);
    double sum = LSsystem::rowMatVecMult(i, lssys.A_, *lssys.x_);

    // Below the indices run as follows:
    // k and l in the right hand side: every second element apart from the boundary:
    //         -1 0 2 4 6 8 ....        X-1 X
    // kk and ll in the restricted residual: every element of course: -1 0 1 2 3 ....


    // Determine indices of b, (k,l) which are the indices in the old fine matrix
    // Indices of elements in b (every second element apart from the boundary)
    // (This may also be calculated as below with old_noX and old_noY
    int k = i%lssys.n1_ - 1; // runs fastest (-1,...,n1-2)
    int l = i/lssys.n1_ - 1;        
    r(kk,ll) = lssys.b_(k,l) - sum; // b - Ax  element

    // in the grid we are
    if (kk == -1 || kk == noX-3) { // 1. stepping from or to the row-boundary
      kk++;
      i += 1;
    }
    else if (kk == noX-2) {        // 2.  at the row-boundary
      if (ll == -1 || ll == noY-3) // 2.a stepping from or to the column-boundary
        i += 1;
      else                         // 2.b at the row boundary, but not as above  
        i += (lssys.n1_+1);           
      kk = -1;
      ll++;
    }
    else {                         // 3. Interior away from boundary
      kk++;
      i += 2;
    }
  }

#ifdef DEBUG_1
  cout << "\n(new) noX,noY = " << noX << "," << noY << endl; 
  cout << "n1_ = " << lssys.n1_ << " n2_ = " << lssys.n2_ << endl;
  cout << "n = n1_*n2_: " << n << endl; 
  cout << "DONE residual_restrictionInjection" << endl;
#endif
}


// ---------------------------------------------------------------------------
static void restrictionFullWeightingLaplace(const GenMatrix<UCBspl_real>& rr, GenMatrix<UCBspl_real>& r) {

  cout << "restrictionFullWeightingLaplace..." << endl;
  
  int old_noX = rr.noX();
  int old_noY = rr.noY();

  // This was taken from restriction of splines, but is it also valid here
  // (or is it too strict since the operator is smaller?)
  if ((old_noX-3)%2 != 0 || (old_noY-3)%2 != 0) {
    cout << "ERROR, invalid grid for projection; see comments in the code above: " << old_noX << " " << old_noY << endl;
    exit(-1);
  }

  // Size of grid at the new coarser level
  int noX = (old_noX-3)/2 + 3;
  int noY = (old_noY-3)/2 + 3;

  r.resize(noX, noY);

  // ??? (Also fix boundary?)

  double op_corners;
  double op_sides; 
  double op_center;
  double op_div;

  // I don't know yet if it has the so-called "variational property":
  // If the interpolation operator and the full weighting operator are transposes of
  // each other up to a constant, it is called a "variational property".
 
  // 
  // Full weighting operator corresponding to the Laplacian problem,
  // i.e., bi-linear restriction
  //
  //          1 2 1
  //          2 4 2 / 16.0
  //          1 2 1
  //
  op_corners =  1.0;
  op_sides  =  2.0; 
  op_center =  4.0;
  op_div    = 16.0; // (But 4.0 is the common denominator)
  

  bool halfWeighting=false;
  if (halfWeighting) {
    // 
    // Half weighting, halfway between full weighting and straight injection
    //
    //          0 1 0
    //          1 4 1 / 8.0
    //          0 1 0
    //
    op_corners =  0.0;
    op_sides  =  1.0; 
    op_center =  4.0;
    op_div    = 8.0;
  }

  // Injection is used on the boundary

  // Rewritten from residual_restrictionInjection where we didn't need to get the whole
  // residual vector.

  // NOTE: See comments on residual_restrictionInjection above and the tech report.
  //
  // Differs from residual_restrictionInjection:
  // Since we will use an operator (above), the full residual vector must be
  // represented for computational efficiency.

  // The residual will be RHS in the residual equation and must be represented
  // as a matrix (corresponds to b_ in this class)  

  //r.fill(0.0); // Must fill since we run through a sparse matrix

  //int n = lssys.n1_*lssys.n2_; // The "one-dimensional" size of the current RHS and soluton vector
  int n = old_noX*old_noY; // The "one-dimensional" size of the old RHS and soluton vector

  int kk = -1;
  int ll = -1;

  // Every second row in A now because of injection
  int i = 0;
  while (i < n) {

    // Below the indices run as follows:
    // k and l in the right hand side: every second element apart from the boundary:
    //         -1 0 2 4 6 8 ....        X-1 X
    // kk and ll in the restricted residual: every element of course: -1 0 1 2 3 ....


    // Determine indices of b
    // Indices of elements in b (every second element apart from the boundary)
    // (This may also be calculated as below with old_noX and old_noY
    //int k = i%lssys.n1_ - 1; // runs fastest (-1,...,n1-2)
    //int l = i/lssys.n1_ - 1;
    
    int k = i%old_noX - 1; // runs fastest (-1,...,n1-2)
    int l = i/old_noX - 1;    

    // cout << '(' << k << ',' << l << ')' << ' ';
    
    // kk and ll are also the indices of b
    // diff r(kk,ll) = lssys.b_(k,l) - sum; // b - Ax  element

    // Injection is used at the boundary (but should we make a proper transposed as for splines?)

    // diff 8 lines
    if (kk == -1 || kk == noX-2 || ll == -1 || ll == noY-2)
      r(kk,ll) = rr(k,l);
    else {
      double val = op_corners * (rr(k-1,l-1) + rr(k-1,l+1) + rr(k+1,l-1) + rr(k+1,l+1)) // corners
         +  op_sides  * (rr(k,l-1) + rr(k,l+1) + rr(k-1,l) + rr(k+1,l))
         +  op_center * rr(k,l);
      r(kk,ll) = val/op_div;
    }
    //r(kk,ll) = 0.0; // ??? test


    if (kk == -1 || kk == noX-3) { // 1. stepping from or to the row-boundary
      kk++;
      i += 1;
    }
    else if (kk == noX-2) {        // 2.  at the right row-boundary
      if (ll == -1 || ll == noY-3) // 2.a stepping from or to the column-boundary
        i += 1;
      else                         // 2.b at the row boundary, but not as above  
        i += (old_noX+1); //i += (lssys.n1_+1);
      kk = -1;
      ll++;
    }
    else {                         // 3. Interior away from boundary
      kk++;
      i += 2;
    }
  }

  // Debug print:
  //double scale = 1.0;
  //::printVTKgrid("qwe_rr.vtk", rr, scale);  
  //::printVTKgrid("qwe_r.vtk", r, scale);  

#ifdef DEBUG_1
  cout << "\n(new) noX,noY = " << noX << "," << noY << endl; 
  cout << "n1_ = " << lssys.n1_ << " n2_ = " << lssys.n2_ << endl;
  cout << "n = n1_*n2_: " << n << endl; 
  cout << "DONE restrictionFullWeightingLaplace" << endl;
#endif
}


// ---------------------------------------------------------------------------
void MGsystem::residual_restrictionFullWeightingLaplace(const LSsystem& lssys, GenMatrix<UCBspl_real>& r) const {

  int old_noX = lssys.n1_;
  int old_noY = lssys.n2_;

  if ((old_noX-3)%2 != 0 || (old_noY-3)%2 != 0) {
    cout << "ERROR, invalid grid for projection; see comments in the code above: " << old_noX << " " << old_noY << endl;
    exit(-1);
  }

  // Find the residual vector (at the current level before coarsening)
  GenMatrix<UCBspl_real> rr; // diff
  residual(lssys, rr);    // diff
  restrictionFullWeightingLaplace(rr, r);
}

// ----------------------------------------------------------------------------------------------
void MGsystem::residual_restrictionSplines(const LSsystem& lssys, GenMatrix<UCBspl_real>& r) const {

  // NOTE: See comments on residual_injection above and the tech report.
  //
  // The residual will be RHS in the residual equation and must be represented
  // as a matrix (corresponds to b_ in this class)
  int old_noX = lssys.n1_;
  int old_noY = lssys.n2_;

  if ((old_noX-3)%2 != 0 || (old_noY-3)%2 != 0) {
    cout << "ERROR, invalid grid for projection; see comments in the code above: " << old_noX << " " << old_noY << endl;
    exit(-1);
  }

  // Find the residual vector (at the current level before coarsening)
  GenMatrix<UCBspl_real> rr;
  residual(lssys, rr);

  UCBspl::restrictCoeffsC2(rr,r);
  
  // Debug print:
  //double scale = 1.0;
  //::printVTKgrid("qwe_rr.vtk", rr, scale);  
  //::printVTKgrid("qwe_r.vtk", r, scale);  

  
  return;
}

// -----------------------------------------------------------------------------------
void MGsystem::relaxAndCorrectVcycle(int noLevelsInVcycle) {
  
  // Relax in V-cycle.
  // -----------------
  // Use the noLevelsInVcycle 'coarsest systems' in systems_
  // Start relaxing at the top level, restrict and relax residuals recursively
  // on the descend leg, and then correct with errors and relax recursively
  // on the ascend leg.
  
  std::vector<int> noIterArr;
  noIterArr.resize(noLevelsInVcycle,noIter_);
  noIterArr[0] = noIterCoarsest_; // Relax more at the lowest level.
  
  // Relax at the finest level
#ifdef DEBUG_0
  //noIterArr[noLevelsInVcycle-1] = 10;
  //noIterArr[noLevelsInVcycle-2] = 0;
  //noIterArr[noLevelsInVcycle-3] = 0;
  //noIterArr[0] = 0; // Coarsest
  cout << "\nrelaxAndCorrectVcycle..." << endl;
  //cout << "Residual l_2_scaled = " << residual_l2(true) << endl;
  cout << "\nLevel " << noLevelsInVcycle-1 << ":\n";
#endif

  systems_[noLevelsInVcycle-1]->relaxGaussSeidel(noIterArr[noLevelsInVcycle-1]);
#ifdef DEBUG_0
  //cout << "Level " << noLevelsInVcycle-1 << " noIter= " << noIterArr[noLevelsInVcycle-1] << "  Residual l_2_scaled = " << systems_[noLevelsInVcycle-1]->residual_l2(true) << endl;
#endif
  
  // Descend in recursion with residual and relax residual equations.
  // In each step:
  //    1) restrict and
  //    2) relax the residual equation
  
  // ??? for test
  const int restrictionType = 1; // 1=splines, 2=direct injection, 3=full weighting Laplace
  for (int i = noLevelsInVcycle-2; i >= 0; i--) {
    if (restrictionType == 1)
      residual_restrictionSplines(*systems_[i+1],r_);  // r = b - Ax
    else if (restrictionType == 2) {
      cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!  Note: Direct injection..." << endl;
      residual_restrictionInjection(*systems_[i+1],r_);
    }
    else if (restrictionType == 3)
      residual_restrictionFullWeightingLaplace(*systems_[i+1],r_);  // r = b - Ax
    
     
    systems_[i]->x_->fill(0.0); // or: e_arr_[i]->fill(0.0);
    systems_[i]->b_.swap(r_);
#ifdef DEBUG_0
    cout << "\nLevel " << i << ":\n";
#endif
    systems_[i]->relaxGaussSeidel(noIterArr[i]); // Relax the residual equation Ae = r
#ifdef DEBUG_0
    //cout << "Level " << i << "  noIter= " << noIterArr[i] << "  Residual l_2_scaled = " << systems_[i]->residual_l2(true) << endl;
#endif
    //cout << "CG..."; systems_[i]->relaxCG(noIterArr[i]); // Relax the residual equation Ae = r
  }
  
  // Ascend:
  // . refine solution to next finer level
  // . add the solution to the error left there
  // . relax
  // The systems are not built when ascending since they are the same as when descending.
  // Only the solution vctor is different. 
  for (int i = 1; i < noLevelsInVcycle; i++) {
    UCBspl::refineCoeffsC2(*systems_[i-1]->x_,e_refined_);
    (*systems_[i]->x_) += e_refined_;
#ifdef DEBUG_0
    cout << "\nLevel " << i << ":\n";
#endif
    systems_[i]->relaxGaussSeidel(noIterArr[i]);
#ifdef DEBUG_0
    //cout << "Level " << i << " noIter= " << noIterArr[i] << "  Residual l_2_scaled = " << systems_[i]->residual_l2(true) << endl;
#endif
  }
#ifdef DEBUG_0  
  cout << ".................................done relaxAndCorrectVcycle.................." << endl;
#endif
}

// -----------------------------------------------------------------------------------
UCBspl::SplineSurface MGsystem::getSplineSurface() const {
  if (systems_.size() == 0)
    return UCBspl::SplineSurface();
  else {
    return UCBspl::SplineSurface(systems_[systems_.size()-1]->x_,umin(), vmin(), umax(), vmax());
  }
}


// -----------------------------------------------------------------------------------
static void restrictionSplines(GenMatrix<UCBspl_real>& PHI, int noLevels) {
  GenMatrix<UCBspl_real> PHIrestricted;
  for (int kk = 0; kk < noLevels; kk++) {
    UCBspl::restrictCoeffsC2(PHI, PHIrestricted);
    //restrictionFullWeightingLaplace(...,...);
    PHI.swap(PHIrestricted);
  }
}

//-------------------------------------------------------------------------
static void calculateDomain(const std::vector<double>& U,
                            const std::vector<double>& V,
                            std::vector<double>& domain) {
  
  if (domain.size() != 4)
    domain.resize(4);

  domain[0] = *std::min_element(U.begin(), U.end());
  domain[1] = *std::min_element(V.begin(), V.end());
  domain[2] = *std::max_element(U.begin(), U.end());
  domain[3] = *std::max_element(V.begin(), V.end());
}


//-------------------------------------------------------------------------
void MGsystem::setDomain(double umin, double vmin, double umax, double vmax) {
  if (domain_.size() != 4)
    domain_.resize(4);

  domain_[0] = umin;
  domain_[1] = vmin;
  domain_[2] = umax;
  domain_[3] = vmax;
}

//-------------------------------------------------------------------------
void MGsystem::getDomain(double& umin, double& vmin, double& umax, double& vmax) {
  umin = domain_[0];
  vmin = domain_[1];
  umax = domain_[2];
  vmax = domain_[3];
}

// --------------------------------------------------------
void MGsystem::reserveResidual() {
   
  // assumes that the multilevel system is initialized
  // for residual equations - not needed by solve ascend
  int noLevels = systems_.size();
  int m_nextToFinest = (systems_[noLevels-1]->n1_-3)/2;
  int n_nextToFinest = (systems_[noLevels-1]->n2_-3)/2;
  r_.reserve(m_nextToFinest+3, n_nextToFinest+3); // noX and noY for level next to finest
}

// ----------------------------------------------------------------- 
void MGsystem::initMultilevel(int m0, int n0, int h,
                              boost::shared_ptr<std::vector<double> > U,
                              boost::shared_ptr<std::vector<double> > V,
                              boost::shared_ptr<std::vector<double> > Zorig,
                              boost::shared_ptr<GenMatrix<UCBspl_real> > x, // solution vector
                              boost::shared_ptr<std::map<int, double> > weights) {
  
  
  // Set.... functions:
  // - lambdaFac_: used by buildSystem (A-matrix in Ax=b) and must thus be set before init.
  //   But it should be possible to run adjust smoothness
  // - noIter_: should be possible to adjust it?
  // - domain: Used by buildSystem, so logically first, but default
  // - LOGI: setXXXX and then init!

  // Used by FMG and V-cycle
  
  if (domain_.size() != 4) // Indicates that setDomain have not been called
    calculateDomain(*U,*V,domain_);

  m0_ = m0;
  n0_ = n0;

  m0 *= 8;
  n0 *= 8;
  h  -= 3;

  // Parameters for multigrid and equation system
  int noLevels = h+1;
  
  if (h < 1) {
    cout << "ERROR in input: At least two layers are required (h >= 4 in MBA) " << endl;
    exit(-1);
  }

  int m_finest = m0 * (2<<(h-1));
  int n_finest = n0 * (2<<(h-1));
  
  int noX = m_finest+3;
  int noY = n_finest+3;

#ifdef DEBUG_LSMG
  cout << "Number of unknowns coefficients: " << noX << 'x' << noY << '=' << noX*noY << endl;
#endif
  
  // Note that x is always regarded as the solution vector at the finest level.
  // But we may also have a startvector for the coarsest possible level (h=4) for multigrid etc.
  if (!x.get())
    x.reset(new GenMatrix<UCBspl_real> );


  if (x->noX() != noX || x->noY() != noY) // (not so relevant here, but in V-cycle we may have a start vector)!
    x->resize(noX,noY);
  
  // Build (i.e., make system matrix A), one system for each level.
  // The same systems are used when descending and ascending inside the same V-cycle.
  // The solution vector and thus the right hand side built from the original z-values,
  // are present only at the top level of the Vcycle.
  // --------------------------------------------------------------------------------

  systems_.resize(noLevels);
  
  // The finest level. This is where the input solution vector is plugged in.
  // The right hand side will be made from the input data here.

  systems_[noLevels-1] = new LSsystem(U,V,Zorig,m_finest+3,n_finest+3,x,lambdaFac_);
  const bool buildRHS=false; // Call it explicitly when needed
  systems_[noLevels-1]->setDomain(umin(),vmin(),umax(),vmax());
  systems_[noLevels-1]->setWeights(weights);
  systems_[noLevels-1]->buildEqSystem(buildRHS);
  
  // And the levels with residual equations
  int prev_noX = systems_[noLevels-1]->n1_;
  int prev_noY = systems_[noLevels-1]->n2_;
  //e_arr_ = new GenMatrix<UCBspl_real>[noLevels-1];

  e_arr_.resize(noLevels-1); // shared pointers

  for (int i = noLevels-2; i >= 0; i--) {
    // Size of grid at the coarser levels
    noX = (prev_noX-3)/2 + 3;
    noY = (prev_noY-3)/2 + 3;
    e_arr_[i].reset(new GenMatrix<UCBspl_real> );
    e_arr_[i]->resize(noX,noY); // When i=0: The lowest level corresp. to h=3 in MBA can be given a start vector if FMG or Ascend

    systems_[i] = new LSsystem(U,V,Zorig,noX,noY,e_arr_[i],lambdaFac_);

    // Set the domain and thus avoid calculating it each time in LSsystem
    systems_[i]->setDomain(umin(),vmin(),umax(),vmax());

    // ??? Can we avoid rebuilding from all the scattered data again
    // at each level. For example, build at the finest level and then restrict.
    // Can this be done in an "operator-manner" like in ordinary Laplacian problems. 

    systems_[i]->setWeights(weights);
    systems_[i]->buildEqSystem(buildRHS); // do not build RHS


    //systems_[i]->setSmoothingFactor(0.015*lambdaFac_); // seems optimal (when lamdaFac_=1.0)
    
    //cout << "!!!!!! adjusting lambdaFac_ at lower levels" << endl;
    //systems_[i]->setSmoothingFactor(lambdaFac_* (double)(i+1)/(double)(noLevels-2) * 0.02);

    prev_noX = noX;
    prev_noY = noY;    
  }

  
  // Reserve arrays before solving in the V-cycle (for solveFMG and full solveVcycle)
  e_refined_.reserve(m_finest+3,n_finest+3);

  //noIter_.resize(noLevels,noIter_);
  //noIter_[0] = noIterCoarsest_; // Relax more at the lowest level.

#ifdef DEMUG_LSMG
  cout << "initializing done" << endl;
#endif
}


// ----------------------------------------------------------------- 
void MGsystem::cleanup() {
  // Arrays common to solvers FMG, V-cycle etc.
  int noLevels = systems_.size();
  for (int i = 0; i < noLevels; i++)
    delete systems_[i];
  systems_.clear();

/* 
  if (e_arr_)
    delete [] e_arr_;
  e_arr_=NULL;
*/
  r_.clear();
  e_refined_.clear();

  domain_.clear();

  rhsFinestLevel_ = false;
}


// ----------------------------------------------------------------- 
static double average(const std::vector<double>& arr) {

  double sum=0.;
  std::vector<double>::const_iterator it;
  for(it = arr.begin(); it != arr.end(); ++it)
    sum += *it;

  return sum/arr.size();

  // No, this copies
  //std::valarray<double> varr(arr.begin(), arr.size());
  //return varr.sum()/varr.size();
}

// ----------------------------------------------------------------- 
// Calculate a starting vector at a given level to start from
// in solveAscend and solveFMG.
void MGsystem::calculateStartVector() const {

#ifdef DEBUG_LSMG
  cout << "Calculating start vector with MBA" << endl;
#endif

  // Base surface is default CONSTLS and ok
  MBA mba(systems_[0]->U_, systems_[0]->V_, systems_[0]->Zvals_);
  mba.setDomain(umin(),vmin(),umax(),vmax());

  int h = 3;
  mba.MBAalg(m0_,n0_,h);

  // Get the tensor product grid which is now the start vector
  boost::shared_ptr<GenMatrix<UCBspl_real> > phi =  mba.getSplineSurface().getCoefficients();
  
  // Initialize at lower lovel in systems
  // ??? Replace unused allocated array, but only 11*11=121 elements
  systems_[0]->x_->init(*phi);
}

// ----------------------------------------------------------------- 
void MGsystem::solveFMG() {
  // (Only use of the private variables common to V-cycle prevents this function from being const)
  
  // Input
  // x is the solution vector and may have been allocated outside.
  // It is plugged directly into the equation system at the finest level now
  // without filling it.
  // (The solution vwctor at the coarsest level is filled with the average ov the z-values
  // i.e., a Schoenberg-like approach).
  
  
  // FMG, Full multigrid
  // -------------------
  // 1) Initialize (as in the Vcycle-algorithm)
  // 2) Relax at the coarsest level
  // 3 Loop:
  //   a) refine one step, build right hand side from the input data, (but do not relax)
  //   b) run V-cycle with the current no. of levels in the current V-cycle
  
  // Thus, when starting a V-cycle, the right hand side is build from the
  // input function data (z-values). Then we recursively make residual equations
  // on the descend-leg and relax. Finally, on the ascend leg, we add the
  // refined error and relax until the upper level gives a new solution to
  // the equation system.

  // The MBA library is used by the MGsystem-library:
  // - Refinement operator (similar to Oslo-algorithm)
  // - Restriction operator when the "variational property" with respect to spline
  //   refinement is used (currently in this file yet?)
  // - The data structure (system matrix and refinement scheme) is similar to the
  //   MBA-library (GenMatrix<type> is used both places)
  // - Also, the notation with m0, n0, and h in the code corresponds to similar notation
  //   in the MBA library. Thus, for a squared domain we give m0=n0=1
  //   (though, in the code we must take   m0 *= 8; n0 *= 8; h  -= 3; for reasons explained below)

  
  // The values of m0, n0 and h, after m0 *= 8; n0 *= 8; h  -= 3, corresponds to the coarsest
  // possible grid to start from:
  // The equation solver require at least h=3 (2^3+3=11 gridlines).
  // and here in MG we require at least two levels.
  // The h-value in this algorithm will be three less than that in the MBA-scheme,
  // since m0 or n0 becomes 8 below.
  // No of refinements is h (the no. of levels is h+1)

  if (systems_.size() == 0)
    errorAndExit("the multilevel system has not been initialized");

  reserveResidual();

  //
  // FMG-scheme:
  // -----------
  // Start relaxing at the coarsest level
  systems_[0]->buildRHS();
  int noLevels = systems_.size();

  // Calculate startvector for the coarsest level
  //systems_[0]->x_->fill(::average(*systems_[noLevels-1]->Zvals_));
  calculateStartVector(); 

  //systems_[0]->relaxGaussSeidel(noIterCoarsest_); // solution vector is present from e_arr, see above
  systems_[0]->relaxCG(noIterCoarsest_);
#ifdef DEBUG_LSMG
  cout << "Residual at coarsest level with CG,  r_l2= " << systems_[0]->residual_l2() << "   l_linf=" << systems_[0]->residual_linf() << endl;
#endif

  // Loop: refine and run next V-cycle
  for (int ii = 1; ii < noLevels; ii++) {
    UCBspl::refineCoeffsC2(*systems_[ii-1]->x_,e_refined_);
    systems_[ii]->x_->swap(e_refined_);

    systems_[ii]->buildRHS();
    int noLevelsInVcycle = ii+1;
    relaxAndCorrectVcycle(noLevelsInVcycle);
  }
 
  // SOLUTION is now in the reference value: systems[noLevels-1]->x_, which is x here

  rhsFinestLevel_ = true;
}

// --------------------------------------------------------------
void MGsystem::solveAscend() {

  if (systems_.size() == 0)
    errorAndExit("the multilevel system has not been initialized");

  //bool reserveResidual = false; // No residual is needed

  systems_[0]->buildRHS();
  int noLevels = systems_.size();

  // Calculate Startvector for the coarsest level
  //systems_[0]->x_->fill(::average(*systems_[noLevels-1]->Zvals_));
  calculateStartVector();
  
  //systems_[0]->relaxGaussSeidel(noIterCoarsest_);
  systems_[0]->relaxCG(noIterCoarsest_);
  for (int i = 1; i < noLevels; i++) {
      // (The role of e_refined_ is not an error here.)
    UCBspl::refineCoeffsC2(*systems_[i-1]->x_,e_refined_);
    systems_[i]->x_->swap(e_refined_);
    systems_[i]->buildRHS();
    systems_[i]->relaxGaussSeidel(noIter_);
    //systems_[i]->relaxCG(noIter_);
  }
  rhsFinestLevel_ = true;
}

//--------------------------------------------------------------
// void MGsystem::solveAscend(double err) {

//   if (systems_.size() == 0)
//     errorAndExit("the multilevel system has not been initialized");

//   systems_[0]->buildRHS();
//   int noLevels = systems_.size();

//   // Calculate Startvector for the coarsest level
//   calculateStartVector();
  
//   // error history
//   const int history_size = 4;
//   vector<double> history(history_size);
//   int hist_pos = 0; // from 0 to (history_size - 1) are valid values

//   double this_error;
//   double last_error;
//   double this_avg;
//   double last_avg;

//   systems_[0]->relaxGaussSeidel(noIterCoarsest_);
//   history[hist_pos++] = systems_[0]->residual_l2();

//   //this_error = systems_[0]->residual_l2();
//   //this_avg = this_error;

//   int krull_counter = 0;
//   do {
//       systems_[0]->relaxGaussSeidel(noIter_);
//       history[hist_pos++] = systems_[0]->residual_l2();

//       int h1 = hist_pos - 1;
//       int h0 = (hist_pos + 2) % 4;

//       double min_diff = 1000000;
//       for (int krull_i = 0; krull_i < 4; ++krull_i) {
// 	  if (krull_i != h1) {
// 	      double this_diff = fabs(history[h1] - history[krull_i]);
// 	      if (this_diff < min_diff) {
// 		  min_diff = this_diff;
// 	      }
// 	  }
//       }

//       double sol_norm = systems_[0]->currentSolutionNorm();

//       cout << lambdaFac_ << " " << 0 << " " << history[h1] << " " <<  history[h1] - history[h0] << " " << min_diff << " " << sol_norm << " " << history[h1] / sol_norm <<  "\n";

//       hist_pos %= history_size;

//       //last_error = this_error;
//       //this_error = systems_[0]->residual_l2();
//       //last_avg = this_avg;
//       //this_avg = (this_error + last_error) / 2;
//       //cout << lambdaFac_ << " " << 0 << " " << this_avg << " " <<  this_avg / last_avg << "\n";

//   } while (krull_counter++ < 399);
//   //while (last_error - this_error > err);


//   for (int i = 1; i < noLevels; i++) {
//       // (The role of e_refined_ is not an error here.)
//       UCBspl::refineCoeffsC2(*systems_[i-1]->x_,e_refined_);
//       systems_[i]->x_->swap(e_refined_);
//       systems_[i]->buildRHS();
//       systems_[i]->relaxGaussSeidel(noIter_);

//       hist_pos = 0;

//       history[hist_pos++] = systems_[i]->residual_l2();

//       //this_error = systems_[i]->residual_l2();
//       //this_avg = this_error;
//       krull_counter = 0;
//       do {
// 	  //systems_[i]->relaxGaussSeidel(noIter_);
// 	  systems_[i]->relaxGaussSeidel(noIter_);
// 	  history[hist_pos++] = systems_[i]->residual_l2();

// 	  int h1 = hist_pos - 1;
// 	  int h0 = (hist_pos + 2) % 4;

// 	  double min_diff = 1000000;
// 	  for (int krull_i = 0; krull_i < 4; ++krull_i) {
// 	      if (krull_i != h1) {
// 		  double this_diff = fabs(history[h1] - history[krull_i]);
// 		  if (this_diff < min_diff) {
// 		      min_diff = this_diff;
// 		  }
// 	      }
// 	  }
// 	  double sol_norm = systems_[i]->currentSolutionNorm();
	  
// 	  cout << lambdaFac_ << " " << i << " " << history[h1] << " " <<  history[h1] - history[h0] << " " << min_diff << " " << sol_norm << " " << history[h1] / sol_norm << "\n";
	  
// 	  hist_pos %= history_size;

// 	  //last_error = this_error;
// 	  //this_error = systems_[i]->residual_l2();

// 	  //last_avg = this_avg;
// 	  //this_avg = (this_error + last_error) / 2;
// 	  //cout << lambdaFac_ << " " << i << " " << this_avg << " " <<  this_avg/ last_avg << "\n";
//       } while (krull_counter++ < 399);
//       // while (fabs(last_error - this_error) / last_error > err);
//   }

//   rhsFinestLevel_ = true;
// }



// -----------------------------------------------------------------
void MGsystem::solveVcycle() {
  cout << "MGsystem::solveVcycle..." << endl;

  if (systems_.size() == 0)
    errorAndExit("the multilevel system has not been initialized");

  reserveResidual();

  // SOLUTION is now in the reference value: systems[noLevels-1]->x_, which is x here

  // Solve in V-cycle: Build right hand side at the finest level and execute the whole V-cycle
  // -----------------------------------------------------------------------------------------
  int noLevels = systems_.size();
  if (!rhsFinestLevel_)
    systems_[noLevels-1]->buildRHS();  //systems_[noLevels-1]->b_.fill(0.0);

  relaxAndCorrectVcycle(noLevels);
  rhsFinestLevel_ = true;
}


// --------------------------------------------------------------
void MGsystem::relax(int numberOfIterations, int relaxType) {

  if (systems_.size() == 0)
    errorAndExit("the multilevel system has not been initialized");
  
  // The solutions vector is present at the finest level
  int noLevels = systems_.size();
  
  if (!rhsFinestLevel_)
    systems_[noLevels-1]->buildRHS();
  rhsFinestLevel_ = true;

  if (relaxType == 1)
    systems_[noLevels-1]->relaxGaussSeidel(numberOfIterations);
  else if (relaxType == 2)
    systems_[noLevels-1]->relaxJacobi(numberOfIterations);
  else if (relaxType == 3)
    systems_[noLevels-1]->relaxCG(numberOfIterations);
  else if (relaxType == 4)
    systems_[noLevels-1]->relaxCGPrecond(numberOfIterations);
  else {
    cout << "No relaxion of that type: " << relaxType << endl;
    exit(-1);
  }
}

// --------------------------------------------------------------
void MGsystem::setSmoothingFactor(double smoothingFac) {

  lambdaFac_ = smoothingFac;
  int noLevels = systems_.size();
  for (int i = 0; i < noLevels; i++) {
    systems_[i]->setSmoothingFactor(lambdaFac_);
  }
}

// --------------------------------------------------------------
bool MGsystem::addPoint(double u, double v, double z, double weight) {
  
  // Update system matrix and RHS for all systems in the hierarchy
  int noLevels = systems_.size();
  const bool addToRHS=true; 
  for (int i = 0; i < noLevels; i++) {
    if (!systems_[i]->addPoint(u,v,z,weight,addToRHS))
      return false;
  }

  // Add the point to the data set (managed by shared pointers)
  systems_[0]->U_->push_back(u);
  systems_[0]->V_->push_back(v);
  systems_[0]->Zvals_->push_back(z);
  
  // also add weight
  if (weight != 1.0)
    (*systems_[0]->weights_.get())[systems_[0]->U_->size()-1] = weight;

  return true;
}


// --------------------------------------------------------------
void MGsystem::setWeight(int pointIndex, double new_weight) {
  
  // We can simply do as follows:
  // 1. "remove the point" using the negative of the existing weight
  // 2. Then add the point again

  // First chech if the point has got a specific weight
  double old_weight = 1.0;
  bool wls = false;

  std::map<int, double>* weights = systems_[0]->weights_.get();
  if (weights && weights->size() != 0) {
    map<int, double, less<int> >::iterator mit = weights->find(pointIndex);
    if(mit != weights->end()) {
       old_weight = (*mit).second;
       wls = true;
    }
  }

  double u = (*systems_[0]->U_)[pointIndex];
  double v = (*systems_[0]->V_)[pointIndex];
  double z = (*systems_[0]->Zvals_)[pointIndex];
  int noLevels = systems_.size();

  // Solving has not necessarily been done at this point such that no
  // right hand sides may exist. See also bottom of function.
  const bool addToRHS = false;

  for (int i = 0; i < noLevels; i++)
    systems_[i]->addPoint(u,v,z,-old_weight,addToRHS);

  // Set the new weight and update weight array
  for (int i = 0; i < noLevels; i++)
    systems_[i]->addPoint(u,v,z,new_weight,addToRHS);

  (*systems_[0]->weights_.get())[pointIndex] = new_weight;

  // Such that RHS is guaranteed to be built again for V-cycle and relax 
  rhsFinestLevel_ = false; 
}


// --------------------------------------------------------------
// OLD solveAscend which is reusing the same equation system
// and not using private members.
// I changed it slightly above such that it fits into the same scheme
// with solvers as FMG.
/*
void MGsystem::solveAscend_orig(int m0, int n0, int h,
                           const std::vector<double>& U,
                           const std::vector<double>& V,
                           const std::vector<double>& Zorig,
                           GenMatrix<UCBspl_real>& PHI,
                           double lambdaFac,
                           int noIter, int noIterCoarsest) {
  
  // This function is not using the private members common to FMG and Vcycle
  // to save memory.
  
  m0 *= 8;
  n0 *= 8;
  h  -= 3;
  int m_finest = m0 * (2<<(h-1));
  int n_finest = n0 * (2<<(h-1));
  int m_nextToFinest = m_finest/2;
  int n_nextToFinest = n_finest/2;
  
  GenMatrix<UCBspl_real> x;
  x.reserve(m_nextToFinest+3,n_nextToFinest+3); // To next to the finest level

  GenMatrix<UCBspl_real>& x_refined = PHI; // just so the final result is present in the output

  cout << "m_finest+3 = " << m_finest+3 << "     n_nextToFinest+3 = " << n_nextToFinest+3 << endl;  

  // Resize and give  a start vector as the mean of the given z-data values
  PHI.clear(); // Free memory since we do not use it now
  x.resize(m0+3,n0+3);
  std::valarray<double> varr(Zorig.begin(), Zorig.size());
  x.fill(varr.sum()/varr.size());
  
  // Also reserve for right hand side, and thus avoid reallocation.
  // (*this is a friend of LSsystem)
  LSsystem system(U,V,Zorig,x.noX(), x.noY(), x, lambdaFac);
  system.b_.reserve(m_finest+3,n_finest+3); // the finest level
  
  // Locals now and not the class members
  int noLevels = h+1;
  std::vector<int> noIter_arr;
  noIter_arr.resize(noLevels,noIter);
  noIter_arr[0] = noIterCoarsest; // Relax more at the lowest level (but is this necessary here?).


  if (domain_.size() != 4) // Indicates that setDomain have not been called
    calculateDomain(U,V,domain_);
    
  system.setDomain(umin(),vmin(),umax(),vmax());

  for (int i = 0; i < noLevels; i++) {
    // ??? Can we avoid running through all the data again to buil A_ and b_ ?
    //     . do some math here (but can we also use this in MBA?)
    // ??? and we should also reserve in the sparse structure A_
    // 
    system.buildEqSystem(true); // Arrays are already reserved (exept from A_)
    system.relaxGaussSeidel(noIter_arr[i]);

    if (i != noLevels-1) {
      MBA::refineLatticeC2(x,x_refined);
      system.x_.swap(x_refined);
    }
  }

  x_refined.clear();
  system.x_.swap(PHI); // Lastly, swap it to MBA
  cout << "Solved grid with size: (" << m_finest+3 << ',' << n_finest+3 << ")  No. unknowns = " << (m_finest+3)*(n_finest+3) << endl;
}
*/


// -----------------------------------------------------------------
// ------------------------- M I S C. -----------------------------
// -----------------------------------------------------------------

/*
static int my_log2(int val) {
  int l=0;
  while (val != 1) {
    val /= 2;
    l++;
  }
  return l;
}
*/
